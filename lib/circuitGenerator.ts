import { Node, Edge } from 'reactflow';

export function generateCircomCode(nodes: Node[], edges: Edge[]): string {
  // Extract inputs, operations, outputs
  const inputs = nodes.filter(n => n.type === 'input');
  const operations = nodes.filter(n => n.type === 'operation');
  const outputs = nodes.filter(n => n.type === 'output');

  // Generate Circom code
  let code = `pragma circom 2.0.0;\n\n`;
  code += `// Auto-generated by zkRune Visual Circuit Builder\n\n`;
  code += `template CustomCircuit() {\n`;
  
  // Inputs
  code += `    // Inputs\n`;
  inputs.forEach(node => {
    const fieldType = node.data.fieldType === 'private' ? 'input' : 'input';
    const varName = node.data.label.toLowerCase().replace(/\s+/g, '_');
    code += `    signal ${fieldType} ${varName};\n`;
  });
  
  code += `\n`;
  
  // Outputs
  code += `    // Outputs\n`;
  outputs.forEach(node => {
    const varName = node.data.label.toLowerCase().replace(/\s+/g, '_');
    code += `    signal output ${varName};\n`;
  });
  
  code += `\n`;
  
  // Operations (simplified - would need graph traversal)
  code += `    // Operations\n`;
  operations.forEach(node => {
    const op = node.data.operation;
    const varName = `temp_${node.id}`;
    
    if (op === 'subtract') {
      code += `    signal ${varName};\n`;
      code += `    ${varName} <== input_a - input_b; // ${node.data.label}\n`;
    } else if (op === 'add') {
      code += `    signal ${varName};\n`;
      code += `    ${varName} <== input_a + input_b; // ${node.data.label}\n`;
    }
  });
  
  code += `\n`;
  code += `    // Simplified output\n`;
  code += `    result <== 1;\n`;
  code += `}\n\n`;
  code += `component main {public []} = CustomCircuit();\n`;
  
  return code;
}

export function validateCircuit(nodes: Node[], edges: Edge[]): { valid: boolean; errors: string[] } {
  const errors: string[] = [];
  
  // Check has at least one input
  const inputs = nodes.filter(n => n.type === 'input');
  if (inputs.length === 0) {
    errors.push('Circuit must have at least one input');
  }
  
  // Check has at least one output
  const outputs = nodes.filter(n => n.type === 'output');
  if (outputs.length === 0) {
    errors.push('Circuit must have at least one output');
  }
  
  // Check all nodes are connected
  const connectedNodes = new Set<string>();
  edges.forEach(edge => {
    connectedNodes.add(edge.source);
    connectedNodes.add(edge.target);
  });
  
  nodes.forEach(node => {
    if (!connectedNodes.has(node.id) && nodes.length > 1) {
      errors.push(`Node "${node.data.label}" is not connected`);
    }
  });
  
  return {
    valid: errors.length === 0,
    errors,
  };
}

export function estimateCircuitComplexity(nodes: Node[], edges: Edge[]): {
  constraints: number;
  estimatedTime: string;
} {
  const operations = nodes.filter(n => n.type === 'operation');
  const constraints = operations.length * 2 + nodes.length;
  
  let estimatedTime = '< 1s';
  if (constraints > 10) estimatedTime = '1-2s';
  if (constraints > 50) estimatedTime = '2-5s';
  
  return { constraints, estimatedTime };
}


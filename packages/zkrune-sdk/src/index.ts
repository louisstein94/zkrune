/**
 * @zkrune/sdk
 * 
 * JavaScript SDK for generating zero-knowledge proofs with zkRune
 * Browser and Node.js compatible
 */

export interface ZKProofOptions {
  templateId: string;
  inputs: Record<string, string>;
  circuitPath?: string;
}

export interface ZKProofResult {
  success: boolean;
  proof?: {
    groth16Proof: any;
    publicSignals: string[];
    verificationKey: any;
    timestamp: string;
    isValid: boolean;
    proofHash: string;
    note: string;
  };
  error?: string;
  timing?: number;
}

/**
 * Generate a zero-knowledge proof
 * 
 * @example
 * ```typescript
 * import { generateProof } from '@zkrune/sdk';
 * 
 * const result = await generateProof({
 *   templateId: 'age-verification',
 *   inputs: {
 *     birthYear: '1995',
 *     currentYear: '2024',
 *     minimumAge: '18'
 *   }
 * });
 * 
 * if (result.success) {
 *   console.log('Proof:', result.proof);
 * }
 * ```
 */
export async function generateProof(options: ZKProofOptions): Promise<ZKProofResult> {
  try {
    const { templateId, inputs, circuitPath } = options;
    const startTime = Date.now();

    // Dynamic import snarkjs
    // @ts-ignore
    const snarkjs = await import('snarkjs');

    // Determine circuit paths (files are in /circuits/ on zkrune.com)
    const basePath = circuitPath || (typeof window !== 'undefined' ? '/circuits' : 'https://zkrune.com/circuits');
    const wasmPath = `${basePath}/${templateId}.wasm`;
    const zkeyPath = `${basePath}/${templateId}.zkey`;
    const vkeyPath = `${basePath}/${templateId}_vkey.json`;

    console.log(`[zkRune SDK] Loading circuit files for ${templateId}...`);

    // Fetch circuit files
    const [wasmResponse, zkeyResponse, vkeyResponse] = await Promise.all([
      fetch(wasmPath),
      fetch(zkeyPath),
      fetch(vkeyPath),
    ]);

    if (!wasmResponse.ok || !zkeyResponse.ok || !vkeyResponse.ok) {
      throw new Error('Failed to load circuit files');
    }

    const [wasmBuffer, zkeyBuffer, vKey] = await Promise.all([
      wasmResponse.arrayBuffer(),
      zkeyResponse.arrayBuffer(),
      vkeyResponse.json(),
    ]);

    console.log(`[zkRune SDK] Generating proof...`);

    // Generate proof
    const { proof: groth16Proof, publicSignals } = await snarkjs.groth16.fullProve(
      inputs,
      new Uint8Array(wasmBuffer),
      new Uint8Array(zkeyBuffer)
    );

    const proofTime = Date.now() - startTime;

    // Verify proof
    const isValid = await snarkjs.groth16.verify(vKey, publicSignals, groth16Proof);

    console.log(`[zkRune SDK] Proof generated in ${proofTime}ms`);

    return {
      success: true,
      proof: {
        groth16Proof,
        publicSignals,
        verificationKey: vKey,
        timestamp: new Date().toISOString(),
        isValid,
        proofHash: JSON.stringify(groth16Proof).substring(0, 66),
        note: `Generated by zkRune SDK in ${(proofTime / 1000).toFixed(2)}s`,
      },
      timing: proofTime,
    };
  } catch (error: any) {
    console.error('[zkRune SDK] Error:', error);
    return {
      success: false,
      error: error.message || 'Failed to generate proof',
    };
  }
}

/**
 * Verify a zero-knowledge proof
 * 
 * @example
 * ```typescript
 * import { verifyProof } from '@zkrune/sdk';
 * 
 * const isValid = await verifyProof({
 *   proof: groth16Proof,
 *   publicSignals: ['1'],
 *   verificationKey: vKey
 * });
 * ```
 */
export async function verifyProof(params: {
  proof: any;
  publicSignals: string[];
  verificationKey: any;
}): Promise<boolean> {
  try {
    // @ts-ignore
    const snarkjs = await import('snarkjs');
    
    const isValid = await snarkjs.groth16.verify(
      params.verificationKey,
      params.publicSignals,
      params.proof
    );

    return isValid;
  } catch (error) {
    console.error('[zkRune SDK] Verification error:', error);
    return false;
  }
}

/**
 * Available zkRune templates
 */
export const templates = {
  AGE_VERIFICATION: 'age-verification',
  BALANCE_PROOF: 'balance-proof',
  MEMBERSHIP_PROOF: 'membership-proof',
  RANGE_PROOF: 'range-proof',
  PRIVATE_VOTING: 'private-voting',
} as const;

export type TemplateId = typeof templates[keyof typeof templates];

